<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1497862872023">{:repl-history {:ide [], :local [&quot;(not nil)&quot; &quot;not nil&quot; &quot;true&quot; &quot;(macroexpand '(when-not (= 1 0) (println \&quot;abc\&quot;)))&quot; &quot;(= 1 0)&quot; &quot;(= nil false)&quot; &quot;not&quot; &quot;(when-not false 'abc)&quot; &quot;(when-not false )&quot; &quot;(defn unless [exp form]\n  (println \&quot;About to test...\&quot;)\n  (if exp nil form))&quot; &quot;(unless true (println \&quot;abc\&quot;))&quot; &quot;(macroexpand '(unless true (println \&quot;abc\&quot;)))&quot; &quot;(if true nil \&quot;abc\&quot;)&quot; &quot;(if flase nil \&quot;abc\&quot;)&quot; &quot;(if false nil \&quot;abc\&quot;)&quot; &quot;(unless false \&quot;abc\&quot;)&quot; &quot;(println \&quot;abc\&quot;)&quot; &quot;(defmacro unless [expr form]\n  `(if ,expr nil ,@form))&quot; &quot;(unless false (println \&quot;abc\&quot;))&quot; &quot;(defmacro unless [expr form]\n  (list 'if expr nil form))&quot; &quot;(macroexpand '(unless false (println \&quot;abc\&quot;)))&quot; &quot;(macroexpand '(.. arm getHand getFinger))&quot; &quot;(macroexpand-1\n  '(.. arm getHand getFinger))&quot; &quot;(doc ..)&quot; &quot;(.. 'a toString)&quot; &quot;(doc .)&quot; &quot;(macroexpand '(. 'a toString))&quot; &quot;(macroexpand '(.. 'a toString))&quot; &quot;(. 'a toString)&quot; &quot;(.'a toString)&quot; &quot;(.toString 'a)&quot; &quot;(macroexpand '(and 1 2 3))&quot; &quot;(clojure.pprint/pprint (macroexpand '(and 1 2 3)))&quot; &quot;(concat (a b c) 'd)&quot; &quot;(concat '(a b c) 'd)&quot; &quot;(concat '(a b c) (d))&quot; &quot;(concat '(a b c) '(d))&quot; &quot;(defmacro chain\n  ([x form] `(. ~x ~form))\n  ([x form &amp; more]\n    `(chain (. ~x ~form) ~@more)))&quot; &quot;(macroexpand '(chain arm gethand getfinger))&quot; &quot;(macroexpand '(chain arm gethand getfinger abc))&quot; &quot;(let [start (System/nanoTime)\n      result (str \&quot;a\&quot; \&quot;b\&quot;)]\n  {:result result :elapsed (- (System/nanoTime) start)})&quot; &quot;(defmacro bench [expr]\n  `(let [start (System/nanoTime)\n         result ~expr]\n     {:result result :elapsed (- (System/nanoTime) start)}))&quot; &quot;(macroexpand '(bench (str \&quot;a\&quot; \&quot;b\&quot;)))&quot; &quot;(macroexpand-1 '(bench (str \&quot;a\&quot; \&quot;b\&quot;)))&quot; &quot;(bench (str \&quot;a\&quot; \&quot;aa\&quot;))&quot; &quot;`foo#&quot; &quot;(defmacro bench [expr]\n  `(let [start# (System/nanoTime)\n         result# ~expr]\n     {:result result# :elapsed (- (System/nanoTime ) start#)}))&quot; &quot;(bench (str \&quot;a b\&quot; \&quot; c\&quot;))&quot; &quot;PI&quot; &quot;Math/PI&quot; &quot;(defn my-print [ob]\n  (.write *out* ob))&quot; &quot;(defn my-println [ob]\n      (my-print ob)\n      (.write *out* \&quot;\\n\&quot;))&quot; &quot;(my-println \&quot;abc\&quot;)&quot; &quot;(println nil)&quot; &quot;(my-println nil)&quot; &quot;(my-println [1 2 3])&quot; &quot;(println [1 2 3])&quot; &quot;(my-print \&quot;foo\&quot;)&quot; &quot;(defmethod my-print String [s]\n  (.write *out* s))&quot; &quot;(my-print \&quot;abc\&quot;)&quot; &quot;(defmethod my-print nil [s]\n           (.write *out* \&quot;nil\&quot;))&quot; &quot;(my-print nil)&quot; &quot;(isa? Integer Number)&quot; &quot;(clojure.string/join \&quot; \&quot; \&quot;abc\&quot;)&quot; &quot;(clojure.string/join \&quot;     \&quot; \&quot;abc\&quot;)&quot; &quot;(require '[clojure.string :as str])&quot; &quot;(defmulti my-print class)&quot; &quot;(defmethod my-print java.util.Collection [c]\n  (.write *out \&quot;(\&quot;)\n  (.write *out* (str/join \&quot; \&quot; c))\n  (.write *out* \&quot;)\&quot;))&quot; &quot;(defmethod my-print java.util.Collection [c]\n  (.write *out* \&quot;(\&quot;)\n  (.write *out* (str/join \&quot; \&quot; c))\n  (.write *out* \&quot;)\&quot;))&quot; &quot;(defmethod my-print clojure.lang.IPersistentVector [c]\n  (.write *out* \&quot;[\&quot;)\n  (.write *out* (str/join \&quot; \&quot; c))\n  (.write *out* \&quot;]\&quot;))&quot; &quot;(my-print '(a b c))&quot; &quot;(my-print [a b c])&quot; &quot;(my-print '[a b c] )&quot; &quot;(my-print (1 2 3))&quot; &quot;(my-print (take 6 (cycle [1 2 3])))&quot; &quot;(my-print '(1 2 3))&quot; &quot;(my-print [1 2 3])&quot; &quot;(prefer-method\n  my-print clojure.lang.IPersistentVector java.util.Collection)&quot; &quot;(my-print [1 2 3\n           ])&quot; &quot;(println [1 2])&quot; &quot;(println '(1 2 3))&quot; &quot;(println \n  (1 2 3))&quot; &quot;:Cheking&quot; &quot;::Cheking&quot; &quot;(defn sum-to [n] (loop [i 1 sum 0]\n                   (if (&lt;= i n) (recur (inc i) (+ i sum)) sum)))&quot; &quot;(sum-to 10)&quot; &quot;(defn better-sum-to [n]\n  (reduce + (range 1 (inc n))))&quot; &quot;(better-sum-to 100)&quot; &quot;(defn best-sum-to [n]\n  (/ (* n (inc n)) 2))&quot; &quot;(defn ^long unchecked-sum-to [^long n]\n  (loop [i 1 sum 0]\n    (if (&lt;= i n)\n      (recur (inc i) (unchecked-add i sum))\n      sum)))&quot; &quot;(dotimes [_ 5] (time (unchecked-sum-to 10000)))&quot; &quot;(defn integer-sum-to [^long n]\n  (loop [i 1 sum 0]\n    (if (&lt;= i n)\n      (recur (inc i) (+ i sum))\n      sum)))&quot; &quot;(integer-sum-to 10)&quot; &quot;(defn ^long integer-sum-to [^long n]\n  (loop [i 1 sum 0]\n    (if (&lt;= i n)\n      (recur (inc i) (+ i sum))\n      sum)))&quot; &quot;(defn ^long integer-sum-to [ n]\n  (loop [i 1 sum 0]\n    (if (&lt;= i n)\n      (recur (inc i) (+ i sum))\n      sum)))&quot; &quot;(integer-sum-to 100)&quot; &quot;(integer-sum-to 10000000000)&quot; &quot;(dotimes [_ 5] (time (better-sum-to 10000)))&quot; &quot;(dotimes [_ 5] (time (sum-to 10000)))&quot; &quot;(dotimes [_ 5] (time (integer-sum-to 10000)))&quot; &quot;(dotimes [_ 5] (time (best-sum-to 10000)))&quot;], :remote []}}</component>
</project>